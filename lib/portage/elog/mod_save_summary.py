# elog/mod_save_summary.py - elog dispatch module
# Copyright 2006-2013 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2

import errno
import time
import corepkg
from corepkg import os
from corepkg import _encodings
from corepkg import _unicode_decode
from corepkg import _unicode_encode
from corepkg.data import corepkg_gid, corepkg_uid
from corepkg.localization import _
from corepkg.package.ebuild.prepare_build_dirs import _ensure_log_subdirs
from corepkg.util import apply_permissions, ensure_dirs, normalize_path


def process(mysettings, key, logentries, fulltext):
    if mysettings.get("PORTAGE_LOGDIR"):
        logdir = normalize_path(mysettings["PORTAGE_LOGDIR"])
    else:
        logdir = os.path.join(
            os.sep, mysettings["BROOT"].lstrip(os.sep), "var", "log", "corepkg"
        )

    if not os.path.isdir(logdir):
        # Only initialize group/mode if the directory doesn't
        # exist, so that we don't override permissions if they
        # were previously set by the administrator.
        # NOTE: These permissions should be compatible with our
        # default logrotate config as discussed in bug 374287.
        logdir_uid = -1
        if corepkg.data.secpass >= 2:
            logdir_uid = corepkg_uid
        ensure_dirs(logdir, uid=logdir_uid, gid=corepkg_gid, mode=0o2770)

    elogdir = os.path.join(logdir, "elog")
    _ensure_log_subdirs(logdir, elogdir)

    # TODO: Locking
    elogfilename = elogdir + "/summary.log"
    try:
        elogfile = open(
            _unicode_encode(elogfilename, encoding=_encodings["fs"], errors="strict"),
            mode="a",
            encoding=_encodings["content"],
            errors="backslashreplace",
        )
    except OSError as e:
        func_call = f"open('{elogfilename}', 'a')"
        if e.errno == errno.EACCES:
            raise corepkg.exception.PermissionDenied(func_call)
        elif e.errno == errno.EPERM:
            raise corepkg.exception.OperationNotPermitted(func_call)
        elif e.errno == errno.EROFS:
            raise corepkg.exception.ReadOnlyFileSystem(func_call)
        else:
            raise

    # Copy group permission bits from parent directory.
    elogdir_st = os.stat(elogdir)
    elogdir_gid = elogdir_st.st_gid
    elogdir_grp_mode = 0o060 & elogdir_st.st_mode

    # Copy the uid from the parent directory if we have privileges
    # to do so, for compatibility with our default logrotate
    # config (see bug 378451). With the "su corepkg corepkg"
    # directive and logrotate-3.8.0, logrotate's chown call during
    # the compression phase will only succeed if the log file's uid
    # is corepkg_uid.
    logfile_uid = -1
    if corepkg.data.secpass >= 2:
        logfile_uid = elogdir_st.st_uid
    apply_permissions(
        elogfilename, uid=logfile_uid, gid=elogdir_gid, mode=elogdir_grp_mode, mask=0
    )

    time_fmt = "%Y-%m-%d %H:%M:%S %Z"
    time_str = time.strftime(time_fmt, time.localtime(time.time()))
    elogfile.write(
        _(
            ">>> Messages generated by process "
            "%(pid)d on %(time)s for package %(pkg)s:\n\n"
        )
        % {"pid": corepkg.getpid(), "time": time_str, "pkg": key}
    )
    elogfile.write(_unicode_decode(fulltext))
    elogfile.write("\n")
    elogfile.close()

    return elogfilename
